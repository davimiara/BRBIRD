/*
 * 		HENRY EQUIPAMENTOS ELETRÔNICOS E SISTEMAS LTDA
 *
 *   Classe principal responsável pelo gerenciamento dos periféricos do Prisma e
 * gerenciamento de todo o sistema.
 *
 *
 * Autor: Eduardo de Andrade
 * Data: 03/06/2010
 *
 * Modificações:
 *
 * ------------------------------------===--------------------------------------
 * Autor: 
 * Data : 
 * Alteração : 
 *   
 * ------------------------------------===--------------------------------------
 * Autor:
 * Data :
 * Alteração :
 * ------------------------------------===--------------------------------------
 *
 *
 */

#include <fcntl.h>
#include <stdio.h>
#include <sstream>
#include <sys/time.h>
#include <henry/general/henryGPIO.h>
#include <henry/general/henryutil.h>
//display
#include <henry/display/interfaceDisplay16x2.h>
#include <henry/display/interfaceDisplay128x64.h>
//sensor
#include <henry/sensor/battery.h>
#include <henry/sensor/paper.h>
#include <henry/sensor/tamper.h>
//cardreader
#include <henry/cardreader/abatrack.h>
#include <henry/cardreader/barcode.h>
#include <henry/cardreader/wiegand.h>
//biometria
#include <henry/biometric/dsp.h>
//mrp
#include <henry/prisma/mrp/mrpManager.h>
#include <henry/prisma/mrp/event/dateTimeEvent.h>
#include <henry/prisma/mrp/command/mrpHeader.h>
//database
#include <henry/prisma/dbPrisma/control/employer.h>
#include <henry/prisma/dbPrisma/dao/employerDao.h>
#include <henry/prisma/dbPrisma/dao/configurationDao.h>
//listener
#include <henry/prisma/socket/command/statusCmd.h>
//rtc
#include <henry/rtc/rtc.h>
#include <henry/general/dirManager.h>
#include <henry/logger/logger.h>
#include <henry/general/leds.h>
#include <henry/cardreader/cardReader.h>
#include <henry/general/cache.h>
#include <henry/printer/printer.h>
#include <henry/prisma/socket/listenerManager.h>
#include <henry/display/InterfaceDisplay.h>
#include <bits/basic_string.h>
#include <unistd.h>
#include <henry/prisma/prismaUtil.h>
#include <henry/prisma/dbPrisma/control/configuration.h>
#include <henry/sensor/sensor.h>
//menus
#include "../include/menu/menuConfig.h"
#include "../include/menu/menuAdmin.h"
#include "../include/menu/menuTamper.h"
//geral
#include "../include/prisma.h"
#include "../include/constants.h"
#include "../include/registryManager.h"
#include "../include/afdManager.h"
#include "../include/instantEmission.h"
#include "../include/menu/menuMessages.h"

#define OK 0
#define ERROR -1

Prisma::Prisma() {
    alertLevel = LVL_OK;
}

Prisma::Prisma(const Prisma & orig) {
}

Prisma::~Prisma() {
}

int Prisma::initGPIOpins(int iGpioFd) {
    try { //initializando interrupções do sistema
        for (int i = 0; i < ARRAY_SIZE(eint_list); i++) {
            cfgPin(iGpioFd, eint_list[i].pin, eint_list[i].cfg);
            setPin(iGpioFd, eint_list[i].pin, eint_list[i].value);
        }
    } catch (...) {

    }
    return OK;
}

/**
 * Carrega configurações do banco de dados.
 * @return
 */
int Prisma::loadConfigurationPrisma() {
    try {
        logger->writeLineData((char*) "Carregando configurações");
        configuration = loadConfiguration(db);
        if (configuration == NULL) {
            logger->writeLineData((char*) "Erro ao carregar configurações");
            return ERROR;
        }

        logger->writeLineData((char*) "Carregando empregador");
        Employer* employer = NULL;
        employer = loadEmployer(db);
        if (configuration == NULL) {
            logger->writeLineData((char*) "Não há empregador");
            //TODO Implementar thread para ficar mostrando mensagem de erro
            return ERROR;
        }
        return OK;
    } catch (...) {

    }
    return ERROR;
}

/* Níveis de alerta do sistema */
int Prisma::setAlertLevel(Prisma::ALERT_LEVEL level, bool turnOn) {
    try {
        if (turnOn) {
            this->alertLevel |= level; //concatenando nível de alerta
        } else {
            this->alertLevel &= ~level; //desetando nível de alerta
        }

        printf("AlertLevel - %d\n", level);

        //Listener manager
        if (alertLevel & LVL_TAMPER)
            listenerManager->terminate();
        else
            listenerManager->initialize(configuration);

        if ((alertLevel & LVL_NO_PAPER) ||
                (alertLevel & LVL_NO_MRP) || (alertLevel & LVL_TAMPER))
            cardReader->terminate();
        else
            cardReader->startThd();

        ((alertLevel & LVL_EXECUTING) ||
                (alertLevel & LVL_NO_PAPER) ||
                (alertLevel & LVL_NO_MRP) ||
                (alertLevel & LVL_TAMPER)) ? biometric->setDspEventHandler(this, NULL) :
                biometric->setDspEventHandler(this,
                &Prisma::biometricReadedEventWrapper);

        if ((alertLevel & LVL_EXECUTING) ||
                (alertLevel & LVL_NO_PAPER) ||
                (alertLevel & LVL_NO_MRP) ||
                (alertLevel & LVL_TAMPER))
            cardCacheMonitor->terminate();
        else
            cardCacheMonitor->startThread();

        ((alertLevel & LVL_EXECUTING) ||
                (alertLevel & LVL_NO_PAPER) ||
                (alertLevel & LVL_NO_MRP) ||
                (alertLevel & LVL_TAMPER)) ? inputInfoMonitor->terminate() :
                inputInfoMonitor->startThread();

        ((alertLevel & LVL_NO_MRP) ||
                (alertLevel & LVL_TAMPER)) ? databaseMonitor->terminate() :
                databaseMonitor->startThread();

        if (tamperVerifier->isBlocked()) {
            (alertLevel & LVL_EXECUTING) ? tamperMonitor->terminate() :
                    tamperMonitor->startThread();
        }

        if (alertLevel & LVL_EXECUTING)
            sensorBattery->terminate();
        else
            sensorBattery->startThd();

        if ((alertLevel & LVL_EXECUTING) || (alertLevel & LVL_NO_PAPER))
            sensorPaper->terminate();
        else
            sensorPaper->startThd();

        if (alertLevel & LVL_NO_MRP) {
            afdManager->terminate(); //gerenciador de AFD
            dirManager->terminate(); //gerenciador de diretórios
        }

        return OK;
    } catch (...) {

    }
    return ERROR;
}


/* Eventos dos sensores */

/* static */
void Prisma::batteryEventWrapper(void* object, void* temp) {
    ((Prisma*) object)->batteryEvent(temp);
}

/* static */
void Prisma::paperEventWrapper(void* object, void* temp) {
    ((Prisma*) object)->paperEvent(temp);
}

/* static */
void Prisma::tamperEventWrapper(void* object, void* temp) {
    ((Prisma*) object)->tamperEvent(temp);
}

/* Mostra evento na interface do menu principal a cada 10 segundos */
void Prisma::batteryEvent(void* temp) {
    int signal = (int) temp;
    timeval now;
    gettimeofday(&now, NULL);
    if ((signal) && (now.tv_sec - lastWarningBatterySensor.tv_sec >
            SENSOR_BATTERY_TIMEOUT)) {
        logger->writeLineData((char*) "Sensor de bateria ativado");
        StatusCmd* statusCmd = new StatusCmd(db);
        statusCmd->setEventStatus(StatusCmd::ES_BT);
        listenerManager->sendEventStatus(statusCmd);
        delete(statusCmd);
        gettimeofday(&lastWarningBatterySensor, NULL);
        if (!(alertLevel & LVL_EXECUTING)) {
            playAudio(AUDIO_BATTERY);
            ((MenuMain*) menuMain)->showMessage(MSG_SNSR_BATERY, S_TO_US(2));
        }
    }
}

/* Mostra evento na interface do menu principal a cada 10 segundos */
void Prisma::paperEvent(void* temp) {
    int signal = (int) temp;
    timeval now;
    gettimeofday(&now, NULL);
    if ((signal) && (now.tv_sec - lastWarningFewPaperSensor.tv_sec >
            SENSOR_FEW_PAPER_TIMEOUT)) {
        logger->writeLineData((char*) "Sensor de papel ativado");
        StatusCmd* statusCmd = new StatusCmd(db);
        statusCmd->setEventStatus(StatusCmd::ES_PP);
        listenerManager->sendEventStatus(statusCmd);
        delete(statusCmd);
        gettimeofday(&lastWarningFewPaperSensor, NULL);
        if (!(alertLevel & LVL_EXECUTING)) {
            playAudio(AUDIO_FEW_PAPER);
            ((MenuMain*) menuMain)->showMessage(MSG_SNSR_FEW_PAPER, S_TO_US(2));
        }
    }
}

void Prisma::tamperEvent(void* temp) {
    int signal = (int) temp;
    if (signal) {
        this->menuMain->pause(true); //só reativa após desbloquear
        if (!tamperVerifier->isBlocked()) {
            logger->writeLineData((char*) "Sensor tamper ativado");
            StatusCmd* statusCmd = new StatusCmd(db);
            statusCmd->setEventStatus(StatusCmd::ES_TP);
            listenerManager->sendEventStatus(statusCmd);
            delete(statusCmd);
            setAlertLevel(LVL_TAMPER, ON);

            logger->writeLineData((char*) "Bloqueando equipamento");
            struct tm dtTm;
            memset(&dtTm, 0, sizeof (tm));
            rtc->getDateTime(&dtTm); //obtendo data hora diretamente do RTC

            tamperVerifier->setBlocked(signal, dtTm);

            //TODO testar zeramento da memória
            //zerando data hora do equipamento
            memset(&dtTm, 0, sizeof (tm));
            dtTm.tm_mday = 1; //dia 1
            dtTm.tm_mon = 0; //mês 1
            dtTm.tm_year = 100; //ano 2000
            dtTm.tm_hour = 0; //hora 0
            dtTm.tm_min = 0; //min 0
            rtc->setDateTime(&dtTm); //configurando data hora no RTC

            //TODO zerar senha de menu
            tamperMonitor->startThread();
        }
        if (!(alertLevel & LVL_TAMPER)) {
            setAlertLevel(LVL_TAMPER, ON);
        }
    }
}

/* static */
void Prisma::printerEventWrapper(void* object, int code, int arg) {
    ((Prisma*) object)->printerEvent(code, arg);
}

void Prisma::printerEvent(int code, int arg) {
    try {
        if (code == PRINTER_FLAG_END_PAPER) {
            if (!(alertLevel & LVL_TAMPER)) {
                timeval now;
                gettimeofday(&now, NULL);
                if (now.tv_sec - lastWarningNoPaper.tv_sec >
                        SENSOR_NO_PAPER_TIMEOUT) {                    
                    logger->writeLineData((char*) "Sem papel na impressora");
                    StatusCmd* statusCmd = new StatusCmd(db);
                    statusCmd->setEventStatus(StatusCmd::ES_SP);
                    listenerManager->sendEventStatus(statusCmd);
                    delete(statusCmd);
                    gettimeofday(&lastWarningNoPaper, NULL);
                    if (!(alertLevel & LVL_EXECUTING)) {
                        playAudio(AUDIO_NO_PAPER);
                        ((MenuMain*) menuMain)->showMessage(
                                MSG_SNSR_NO_PAPER, S_TO_US(2));
                    }
                }
                if (this->paperStatus != code) {
                    setAlertLevel(LVL_NO_PAPER, ON);
                    this->paperStatus = code;
                }
            }
        } else if (code == PRINTER_FLAG_COMMUNICATION_ERROR) {
            if (!(alertLevel & LVL_TAMPER)) {
                timeval now;
                gettimeofday(&now, NULL);
                if (now.tv_sec - lastWarningPrinterError.tv_sec >
                        SENSOR_PRINTER_COMMUNICATION_TIMEOUT) {
                    logger->writeLineData((char*) "Erro de comunicacao com a impressora");
                    StatusCmd* statusCmd = new StatusCmd(db);
                    statusCmd->setEventStatus(StatusCmd::ES_FI);
                    listenerManager->sendEventStatus(statusCmd);
                    delete(statusCmd);
                    gettimeofday(&lastWarningPrinterError, NULL);
                    if (!(alertLevel & LVL_EXECUTING)) {
                        playAudio(AUDIO_NO_PAPER);
                        ((MenuMain*) menuMain)->showMessage(
                                MSG_SNSR_PRINTER_COMUNNICATION, S_TO_US(2));
                    }
                }
                if (this->printerError != code) {
                    setAlertLevel(LVL_NO_PAPER, ON);
                    this->printerError = code;
                }
            }
        } else if (code == PRINTER_FLAG_PAPER_OK) {
            if (alertLevel & LVL_NO_PAPER) {
                if ((this->paperStatus != code) || (this->printerError != code)) {
                    logger->writeLineData((char*) "Impressora alimentada");
                    this->paperStatus = code;
                    this->printerError = code;
                    lastWarningNoPaper.tv_sec -= SENSOR_PRINTER_COMMUNICATION_TIMEOUT;
                    lastWarningFewPaperSensor.tv_sec -= SENSOR_FEW_PAPER_TIMEOUT;
                    setAlertLevel(LVL_NO_PAPER, OFF);
                }
            }
        }
    } catch (...) {

    }
}


/* Buffer leitora */

/*static*/
void Prisma::cardReadedEventWrapper(void* object, char* temp) {
    ((Prisma*) object)->cardReadedEvent(temp);
}

/**
 * Recebe e armazena dados da leitora.
 * @param temp
 */
void Prisma::cardReadedEvent(char* temp) {
    char msg[64];
    sprintf(msg, "Cartão lido - %s", temp);
    logger->writeLineData(msg);
    if (strlen(temp) > 0) {
        char card[32] = "";
        strcpy(card, temp);
        if (telematica->isInitialized()) { //verificando se utiliza telematica
            logger->writeLineData((char*) "Verificando telemática");
            string originalRegistration = card;
            string decrypted = ""; //descriptografando...
            if (telematica->decrypt(originalRegistration, decrypted,
                    Telematica::DT_12) == OK) { //tenta primeiro com 12 dígitos
                strcpy(card, decrypted.c_str());
            } else if (telematica->decrypt(originalRegistration, decrypted,
                    Telematica::DT_8) == OK) { //depois com 8 dígitos
                strcpy(card, decrypted.c_str());
            }
        }
        cacheCardReader->dumpCache();
        //strlen(temp) + 1 para contar também o '\0'
        cacheCardReader->addData((unsigned char*) temp, strlen(card) + 1);
        //iniciando a validação e gravação do registro
        Threader* threader = new Threader();
        threader->setEventHandler(this, NULL, &Prisma::doRegistryWrapper);
        threader->startThread(); //executando método em thread
    } else {
#ifdef PRISMA_DISPLAY_128X64

#else
        playAudio(AUDIO_REGISTRY_NOK);
        ((MenuMain*) menuMain)->showMessage(MSG_REGISTRY_READ_ERROR, S_TO_US(2));
#endif
    }
    return;
}

void Prisma::biometricReadedEventWrapper(void* object,
        unsigned int registration, unsigned char flag, bool ismaster) {
    ((Prisma*) object)->biometricReadedEvent(registration, flag, ismaster);
}

void Prisma::biometricReadedEvent(unsigned int registration, unsigned char flag,
        bool ismaster) {
    char msg[64] = "";
    sprintf(msg, "Biometria lida - %d", registration);
    logger->writeLineData(msg);
    if (flag == DSP_SUCESS) {
        char nRegistration[20] = "";
        sprintf(nRegistration, "%d", registration);
        cacheCardReader->dumpCache();
        cacheCardReader->addData((unsigned char*) nRegistration,
                strlen(nRegistration) + 1);
        doRegistry(); //iniciando a validação e gravação do registro

#ifdef PRISMA_DISPLAY_128X64

#else
    } else if (flag == DSP_NOT_FOUND) {
        playAudio(AUDIO_REGISTRY_NOK);
        ((MenuMain*) menuMain)->showMessage(MSG_REGISTRY_NOT_FOUND, S_TO_US(2));
    } else {
        playAudio(AUDIO_REGISTRY_NOK);
        ((MenuMain*) menuMain)->showMessage(MSG_REGISTRY_READ_ERROR, S_TO_US(2));
#endif
    }
}

/* Buffer teclado */

/*static*/
void Prisma::keyPressedEventWrapper(void* object, char temp) {
    ((Prisma*) object)->keyPressedEvent(temp);
}

/*static*/
void Prisma::keyReleasedEventWrapper(void* object, char temp) {
    ((Prisma*) object)->keyReleasedEvent(temp);
}

/* Armazena tecla presisonada */
void Prisma::keyPressedEvent(char temp) {
    gettimeofday(&lastTimePressedKey, NULL);
}

/**
 * //Armazena tecla solta
 * @param temp
 */
void Prisma::keyReleasedEvent(char temp) {
    unsigned char aux[1];
    aux[0] = (unsigned char) temp;
    cacheKeyboard->addData(aux, 1);
}

/* Caches */

/*static*/
void Prisma::verifyCardCacheWrapper(void* object, void* args) {
    ((Prisma*) object)->verifyCardCache(args);
}

/*static*/
void Prisma::verifyKeyboardCacheWrapper(void* object, void* args) {
    ((Prisma*) object)->verifyKeyboardCache(args);
}

/*
 * Verifica a cache de cartões
 */
void Prisma::verifyCardCache(void* args) {
    int dataAvailable = cacheCardReader->dataAvaliable();
    if (dataAvailable >= CARD_MAX_DIGITS) { //se cache atingiu tamanho máximo...
        setAlertLevel(LVL_EXECUTING, ON);
        char msg[64] = "";
        unsigned char card[dataAvailable + 1];
        memset(card, 0, dataAvailable + 1);
        cacheCardReader->copyData(card, dataAvailable); //lendo cartão
        menuMain->pause(true);
        usleep(100000);
        sprintf(msg, MSG_CANCEL_REGISTRY, (char*) card);
        showMessage(msg, 0, 0); //Pede se usuário quer marcar o ponto
        //aguarda confirmação do usuário sobre entrada
        int option = ((MenuMain*) menuMain)->readOptionMenu();
        if ((option == MENU_OPT_CONFIRM) || (option == MENU_OPT_NEXT)) {
            setAlertLevel(LVL_EXECUTING, OFF); //removendo alerta
            cacheCardReader->addData((unsigned char*) "\0", 1);
            doRegistry(); //realizando registro do ponto
        } else { //se usuário saiu...
            setAlertLevel(LVL_EXECUTING, OFF); //removendo alerta
            cacheCardReader->dumpCache(); //esvazia cache
            menuMain->pause(false); //despausando menu
        }
    }
    return;
}

/*static*/
void Prisma::verifyInfoMonitorWrapper(void* object, void* args) {
    ((Prisma*) object)->verifyInfoMonitor(args);
}

/* verifica a cache de cartões */
void Prisma::verifyInfoMonitor(void* args) {
    try {
        if (this->alertLevel == LVL_OK) {
            timeval now;
            gettimeofday(&now, NULL);
            if ((now.tv_sec - lastTimePressedKey.tv_sec > INPUT_INFO_TIMEOUT)) {
                cacheCardReader->dumpCache(); //elimina o resto da cache
                menuMain->pause(false);
            }
        }
    } catch (...) {

    }
}

/* static */
void Prisma::verifyTamperWrapper(void* object, void* args) {
    ((Prisma*) object)->verifyTamper(args);
}

void Prisma::verifyTamper(void* args) {
    try {
        this->setAlertLevel(LVL_TAMPER, ON);
#ifdef PRISMA_DISPLAY_128X64
        //((InterfaceDisplay128x64*) display)->

#else
        ((InterfaceDisplay16x2*) display)->print(MSG_SNSR_TAMPER, 0, 0);
#endif
        sleep(1);
    } catch (...) {

    }
}

/* static */
void Prisma::verifyDataBaseModificationsWrapper(void* object, void* args) {
    ((Prisma*) object)->verifyDataBaseModifications(args);
}

void Prisma::verifyDataBaseModifications(void* args) {
    try {
        DbPersistent::checkDbLog(db);
    } catch (...) {

    }
}

/* static */
void Prisma::doAFDWrapper(void* object, void* args) {
    ((Prisma*) object)->doAFD();
    return;
}

int Prisma::doAFD() {
    try {
        //Verifica se nada está sendo executado e se mrp comunica
        if ((!(alertLevel & LVL_EXECUTING)) && (!(alertLevel & LVL_NO_MRP))) {
            logger->writeLineData("Gerando AFD");
            //verificando se equipamento está bloqueados
            setAlertLevel(Prisma::LVL_EXECUTING, ON); //travando para processar
            menuMain->pause(true); //pausando menu principal
            afdManager = new AfdManager(db, display,
                    MrpManager::getInstance((char*) DEF_MRP_DEV), logger,
                    configuration, wave);
            afdManager->generate(DIR_AFD); //gerando arquivo afd
            do { //espera término da gravação do AFD para continuar
                usleep(500000);
            } while (afdManager->isRunning());
            usleep(1000);
            delete(afdManager);
            afdManager = NULL;
            dirManager->umontDir(DIR_AFD);
            dirManager->eraseDir(DIR_AFD);
            StatusCmd* statusCmd = new StatusCmd(db);
            statusCmd->setEventStatus(StatusCmd::ES_AFD);
            listenerManager->sendEventStatus(statusCmd);
            delete(statusCmd);
            setAlertLevel(Prisma::LVL_EXECUTING, OFF); //liberando equipamento
            menuMain->pause(false);
            logger->writeLineData("Geração do AFD finalizada");
            return OK;
        }
    } catch (...) {

    }
    return ERROR;
}

/* static */
void Prisma::doRegistryWrapper(void* object, void* args) {
    ((Prisma*) object)->doRegistry();
    return;
}
/**
 *
 * @return
 */
int Prisma::doRegistry() {
    try {
        if (alertLevel == LVL_OK) {
            logger->writeLineData("Iniciando tratamento de registro");
            //Verifica se existe cartão na cache
            int dataAvailable = cacheCardReader->dataAvaliable();
            setAlertLevel(Prisma::LVL_EXECUTING, ON);
            unsigned char card[dataAvailable];
            memset(card, 0, dataAvailable);
            cacheCardReader->getData(card, dataAvailable); //lendo cartão
            cacheCardReader->dumpCache(); //elimina o resto da cache
            RegistryManager* regManager = new RegistryManager(db,
                    configuration, printer, display, leds, wave, biometric,
                    listenerManager, telematica);
            regManager->setShowMessageEventHandler(menuMain,
                    (void*) S_TO_US(1),
                    MenuMain::showMessageWrapper);
            if (!menuMain->isPaused()) //pausando
                menuMain->pause(true);
            regManager->validate((char*) card); //validando ponto
            delete(regManager); //deletando gerenciador de registro
            menuMain->pause(false);
            inputInfoMonitor->terminate();
            setAlertLevel(Prisma::LVL_EXECUTING, OFF);
            logger->writeLineData("Tratamento de registro finalizado");
            return OK;
        }
    } catch (...) {

    }
    return ERROR;
}

/**
 * Realiza a chamada da classe responsável pela validação do registro.
 * @return
 */
int Prisma::doInstantEmission() {
    int result = ERROR;
    try {
        if ((!(alertLevel & LVL_NO_PAPER)) && (!(alertLevel & LVL_NO_MRP))) {
            logger->writeLineData("Gerando emissão instantânea");
            //verificando se equipamento está bloqueados
            setAlertLevel(Prisma::LVL_EXECUTING, ON); //travando para processar
            menuMain->pause(true); //pausando menu principal
            InstantEmissionManager* instantEmission =
                    new InstantEmissionManager(db, display, configuration,
                    MrpManager::getInstance((char*) DEF_MRP_DEV), logger, rtc,
                    printer, wave);
            instantEmission->generate();
            do { //espera término da gravação do AFD para continuar
                usleep(500000);
            } while (instantEmission->isRunning());
            usleep(1000);
            delete(instantEmission);
            instantEmission = NULL;
            //resetando evento de impressora
            printer->setEventHandler(this, &Prisma::printerEventWrapper);
            StatusCmd* statusCmd = new StatusCmd(db);
            statusCmd->setEventStatus(StatusCmd::ES_EI);
            listenerManager->sendEventStatus(statusCmd);
            delete(statusCmd);
            setAlertLevel(Prisma::LVL_EXECUTING, OFF); //liberando equipamento
            menuMain->pause(false);
            result = OK;
            logger->writeLineData("Emissão instantânea finalizada");
        }
    } catch (...) {

    }
    return result;
}

int Prisma::doErrorMRP() {
    try { //Erro ao comunicar com a MRP, travando sistema
        this->menuMain->pause(true);
        setAlertLevel(LVL_NO_MRP, ON);
#ifdef PRISMA_DISPLAY_128X64
        //((InterfaceDisplay128x64*) display)->
        display = new InterfaceDisplay128x64(iGpioFd);
#else
        ((InterfaceDisplay16x2*) display)->clearDsp();
        ((InterfaceDisplay16x2*) display)->setPosition(0, 0);
        ((InterfaceDisplay16x2*) display)->print(MSG_ERROR_MRP);
#endif
        return OK;
    } catch (...) {

    }
    return ERROR;
}

/**
 * Verifica a cache de teclado.
 * @param args
 */
void Prisma::verifyKeyboardCache(void* args) {
    //Verifica tecla digitada.    
    if (cacheKeyboard->dataAvaliable() > 0) {
        char log[256] = "";
        unsigned char data[1];
        cacheKeyboard->getData(data, 1); //pega somente um caractere digitado
        cacheKeyboard->dumpCache(); //elimina o resto da cache

        if ((tamperVerifier->isBlocked()) && (data[0] != MENU_OPT_I)) {
            //equipamento bloqueado, porém permite emissão instantânea (MENU_OPT_I)
            tamperMonitor->terminate();
            MenuTamper* menuTamper = new MenuTamper(cacheKeyboard,
                    display, db, tamperVerifier, tamper, sensorTamper);
            menuTamper->executeMenu();
            usleep(100000);
            delete(menuTamper);
            if (tamperVerifier->isBlocked()) {
                //mantendo mensagem de bloqueio
                tamperMonitor->startThread();
            } else {
                //desbloqueando equipamento
                setAlertLevel(Prisma::LVL_TAMPER, OFF);
                menuMain->pause(false);
            }
        } else {
            //equipamento desbloqueado
            sprintf(log, "Dado lido: %c", data[0]);
            logger->writeLineData(log);
            timeval now;
            gettimeofday(&now, NULL);
            switch ((char) data[0]) {
                case MENU_OPT_ENTER:
                { //Inicializa menu
                    menuMain->pause(true);
                    setAlertLevel(Prisma::LVL_EXECUTING, ON);
                    menuConfiguration = MenuConfig::getInstance(cacheKeyboard,
                            display, db);
                    menuConfiguration->executeMenu();
                    printf("Saindo do menu\n");
                    menuMain->pause(false);
                    setAlertLevel(Prisma::LVL_EXECUTING, OFF);
                }
                    break;
                case MENU_OPT_CONFIRM:
                {
                    if (alertLevel == LVL_OK) {
                        if (cacheCardReader->dataAvaliable() > 0) {
                            //adicionando \0 na string da cache card Reader
                            cacheCardReader->addData((unsigned char*) "\0", 1);
                            doRegistry(); //chamando doRegistry()
                        } else {
                            //verifica se biometria está habilitada
                            if (configuration->getTpBiometric() != Configuration::BT_NONE) {
                                if (configuration->getVerify1_N()) { //ser for 1:N
                                    cacheCardReader->addData((unsigned char*) "\0", 1);
                                    doRegistry(); //chamando doRegistry()
                                }
                            }
                        }
                    } else if (alertLevel & LVL_NO_PAPER) {
                        playAudio(AUDIO_NO_PAPER);
                        ((MenuMain*) menuMain)->showMessage(
                                MSG_SNSR_NO_PAPER, S_TO_US(2));
                    }
                }
                    break;
                case MENU_OPT_CANCEL:
                {
                    if (cacheCardReader->dataAvaliable() > 0) {
                        cacheCardReader->dumpCache();
                        menuMain->pause(false);
                    }
                }
                    break;
                case MENU_OPT_ERASE:
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                {
                    if (alertLevel == LVL_OK) {
                        //menu entrada de dados
                        //fica recebendo numeros até completar e retorna matrícula lida
                        logger->writeLineData((char*) "Entrada de dados");
                        int dataAvailableCacheReader =
                                cacheCardReader->dataAvaliable();
                        sprintf(log, "Dados na cache de cartão: %d",
                                dataAvailableCacheReader);
                        /* Atenção: o '\0' do cartão é adicionado automaticamente após
                           o usuário pressionar "confirm" ou atingir 20 dígitos */
                        unsigned char card[dataAvailableCacheReader + 2];
                        if (data[0] == MENU_OPT_ERASE) {
                            if (dataAvailableCacheReader > 0) {
                                //apagando último caractere
                                cacheCardReader->getData(card, dataAvailableCacheReader);
                                cacheCardReader->addData(card, --dataAvailableCacheReader);
                                card[dataAvailableCacheReader] = '\0'; //setando final
                                if (cacheCardReader->dataAvaliable() == 0) {
                                    inputInfoMonitor->terminate();
                                    menuMain->pause(false);
                                    break;
                                }
                            }
                        } else {
                            inputInfoMonitor->startThread();
                            if (dataAvailableCacheReader < CARD_MAX_DIGITS) {
                                cacheCardReader->addData(data, 1); //adicionando
                            }
                            //copiando cache com novo dado já adicionado
                            cacheCardReader->copyData(card, ++dataAvailableCacheReader);
                            card[dataAvailableCacheReader] = '\0'; //setando final
                        }

                        if (dataAvailableCacheReader > 0) { //se houver dados...
                            //Printando no display
                            ((MenuMain*) menuMain)->print((char*) card);
                        }
                    } else if (alertLevel & LVL_NO_PAPER) {
                        playAudio(AUDIO_NO_PAPER);
                        ((MenuMain*) menuMain)->showMessage(
                                MSG_SNSR_NO_PAPER, S_TO_US(2));
                    }
                }
                    break;
                case MENU_OPT_I:
                {
                    if ((now.tv_sec - lastTimePressedKey.tv_sec >
                            INSTANT_EMISSION_TIMEOUT)) {
                        menuMain->pause(true);
                        logger->writeLineData((char*) "Emissão instantânea ativada");
                        doInstantEmission();
                        menuMain->pause(false);
                    }
                }
                    break;
                case MENU_OPT_SPACE:
                {
                    if ((now.tv_sec - lastTimePressedKey.tv_sec >
                            MENU_CONFIG_TIMEOUT)) {
                        logger->writeLineData((char*) "Inicializando menu "
                                "de administração");
                        setAlertLevel(Prisma::LVL_EXECUTING, ON);
                        menuMain->pause(true);
                        menuAdmin = MenuAdmin::getInstance(cacheKeyboard,
                                display, db);
                        menuAdmin->executeMenu();
                        setAlertLevel(Prisma::LVL_EXECUTING, OFF);
                        menuMain->pause(false);
                    }
                }
                    break;
            }
        }
    }
}

/* static */
void Prisma::changedDateTimeEventWrapper(void* object, tm* oldtime, tm * newTime) {
    ((Prisma*) object)->changedDateTimeEvent(oldtime, newTime);
}

void Prisma::changedDateTimeEvent(tm* oldtime, tm * newTime) {
    try {
        char oldTimeStr[64] = ""; //gravando dados no log
        char newTimeStr[64] = "";
        char log[256] = "Gravando alteração de data e hora na MRP - %s -> %s";
        getDateTime(oldtime, oldTimeStr);
        getDateTime(newTime, newTimeStr);
        sprintf(log, oldTimeStr, newTimeStr);
        logger->writeLineData(log); //enviado para logger

        int evtQtty = 0;
        int trys = 0;
        int result = ERROR;
        do { //recebendo quantidade para calcular próximo NSR
            result = mrpManager->receiveQttyEvents(&evtQtty);
        } while ((result != MRP_ERROR_NONE) && (++trys < DEF_TRYS));

        if (result == MRP_ERROR_NONE) {
            Event* dateTime = new DateTimeEvent(++evtQtty, oldtime, newTime);
            trys = 0;
            do { //Tentando enviar o registro à MRP - 3 tentativas
                result = mrpManager->sendEvent(dateTime);
                if (result == MRP_ERROR_INVALID_NSR)
                    dateTime->setNSR(++evtQtty); //incrementando nsr
            } while ((result != MRP_ERROR_NONE) && (++trys < DEF_TRYS));

            if (result == MRP_ERROR_NONE) {
                string temp;
                StatusCmd* statusCmd = new StatusCmd(db);
                dateTime->getEventLine(temp);
                statusCmd->setParam(temp);
                statusCmd->setEventStatus(StatusCmd::ES_EV);
                listenerManager->sendEventStatus(statusCmd);
                delete(statusCmd);
            }
            delete(dateTime); //removendo registro da memória
        }
        if (result != MRP_ERROR_NONE) {
            doErrorMRP();
        }
    } catch (...) {

    }
}

/* static */
void Prisma::dirManagerEventWrapper(void* object, int param) {
    ((Prisma*) object)->dirManagerEvent(param);
}

void Prisma::dirManagerEvent(int param) {
    try {
        switch (param) {
            case DIR_ADDED:
            { //Diretório adicionado
                logger->writeLineData("Diretório /usb1/ detectado");
                Threader* threader = new Threader();
                threader->setEventHandler(this, NULL, &Prisma::doAFDWrapper);
                threader->startThread(); //executando método em thread
            }
                break;
            case DIR_REMOVED:
            { //Diretório removido
                logger->writeLineData("Diretório /usb1/ removido");
                if (afdManager != NULL) { //finalizando a geração do AFD
                    afdManager->terminate();
                }
            }
                break;
        }
    } catch (...) {

    }
}

/* static */
int Prisma::requestedDateTimeEventWrapper(void* object, tm* dateTime) {
    ((Prisma*) object)->requestedDateTimeEvent(dateTime);
}

int Prisma::requestedDateTimeEvent(tm* dateTime) {
    try {
        if (rtc != NULL)
            return rtc->getDateTime(dateTime);
    } catch (...) {

    }
    return ERROR;
}

/**
 * Configura o dsp com velocidade 115200.
 */
int Prisma::configureDSP() {
    try {
        unsigned char list[4]; //lista de usuários
        int result = ERROR;
        unsigned int resp = 0;
        unsigned char flag;
        //Verificando se está comunicando
        result = biometric->listUsr(0, 1, &resp, &flag, list);
        if ((result == OK) && (flag == DSP_SUCESS)) {
            return OK;
        } else {
            logger->writeLineData((char*) "Configurando velocidade da biometria");
            //Verifica se está comunicando em 9600
            biometric->setBaudRate(Dsp::BR9600);
            result = biometric->listUsr(0, 1, &resp, &flag, list);
            if ((result == OK) && (flag == DSP_SUCESS)) {
                //Troca velocidade para 115200
                biometric->changeBaudRate(Dsp::BR115200, &flag);
                return (flag == DSP_SUCESS) ? OK : ERROR;
            }
        }
    } catch (...) {

    }
    return ERROR;
}

int Prisma::showMessage(string message, int x, int y) {
    try {
        if (display != NULL) {
#ifdef PRISMA_DISPLAY_128X64

#else
            ((InterfaceDisplay16x2*) display)->clearDsp();
            ((InterfaceDisplay16x2*) display)->setPosition(x, y);
            ((InterfaceDisplay16x2*) display)->print(message.data());
#endif
        }
    } catch (...) {

    }
    return OK;
}

int Prisma::playAudio(string audio) {
    stringstream wavePath;
    wavePath << DIR_HOME << DIR_PRISMA << DIR_AUDIO << audio;
    return wave->play((char*) wavePath.str().c_str());
}

int Prisma::init(const char* sDb, const char* sLogFile) {

    //100ms de delay e gravando data e hora
    logger = Logger::getInstance((char*) sLogFile, 1024, 1, true);
    logger->setGetDateTimeEventHandler(this,
            &Prisma::requestedDateTimeEventWrapper);

    //Inicializando rtc - controle de data e hora do sistema
    rtc = HRtc::getInstance((char*) DEF_I2CBUS);
    if (rtc->connect() == OK) {
        logger->writeLineData((char*) "Rtc inicializado com sucesso");
        rtc->setChangedDateTimeEventHandler(this,
                &Prisma::changedDateTimeEventWrapper);
    } else {
        logger->writeLineData((char*) "Falha ao abrir canal i2c com rtc");
        //TODO mensagem no display e bloqueio do equipamento
    }

    logger->writeLineData((char*) "Logger inicializado");

    /* Inicializando carregando banco de dados */
    logger->writeLineData((char*) "Carregando informações do banco de dados");
    logger->writeLineData(sDb);
    int iRes = sqlite3_open(sDb, &this->db);
    if (iRes != SQLITE_OK) {
        logger->writeLineData("erro ao conectar no banco");
    }

    //Inicializando componentes de hardware
    int iGpioFd = open(DEF_GPIOKEYBORD, O_RDWR);
    if (iGpioFd < 0) {
        logger->writeLineData((char*) "Erro ao inicializar barramento GPIO");
        //TODO resetar placa
    } else {
        logger->writeLineData((char*) "Barramento GPIO aberto");
    }

    initGPIOpins(iGpioFd); //inicializando IRQ's não utilizados


    if (loadConfigurationPrisma() != OK) {
        //todo algo;

    }

    logger->writeLineData((char*) "Inicializando Sistema Prisma");

    logger->writeLineData((char*) "Inicializando sistema watchdog");
    watchdog = new WatchDog(DEF_WATCHDOG_DEV);
    //TODO Reativar watchdog
    /*
    if (watchdog->watch() == OK) {
        logger->writeLineData((char*) "Sucesso ao inicializar sistema watchdog");
    } else {
        logger->writeLineData((char*) "Falha ao inicializar sistema watchdog");
    }
     */

    //Inicializando display
    //printando nome e versão do fw
    logger->writeLineData((char*) "Inicializando display");

#ifdef PRISMA_DISPLAY_128X64
    //((InterfaceDisplay128x64*) display)->
    display = new InterfaceDisplay128x64(iGpioFd);
#else
    display = new InterfaceDisplay16x2(iGpioFd);
    ((InterfaceDisplay16x2*) display)->print(FW_NAME);
    ((InterfaceDisplay16x2*) display)->print(FW_VERSION, 1, 3);
#endif

    logger->writeLineData((char*) "Inicializando MRP");

    //Inicializando a MRP
    mrpManager = MrpManager::getInstance((char*) DEF_MRP_DEV);
    if (mrpManager->init() == OK) {
        logger->writeLineData((char*) "Mrp inicializada com sucesso");
    } else {
        logger->writeLineData((char*) "Falha ao inicializar mrp");
        //TODO mensagem no display e bloqueio do equipamento
    }

    logger->writeLineData((char*) "Criando gerenciador de sockets");

    printf("Criando listener manager\n");
    listenerManager = ListenerManager::getInstance(db);
    if (listenerManager->initialize(configuration) == OK) {
        logger->writeLineData((char*) "Gerenciador de sockets inicializado "
                "com sucesso");
    } else {
        logger->writeLineData((char*) "Falha ao inicializar gerenciador de "
                "sockets");
        //TODO mensagem no display - equipamento está sem comunicação
    }

    //Inicializando tamper
    logger->writeLineData((char*) "Inicializando tamper");
    tamper = new Tamper();
    //verificando se equipamento está ou não bloqueado
    stringstream tamperPath;
    tamperPath << DIR_HOME << DIR_PRISMA << DIR_DOCS << FILE_TAMPER;
    tamperVerifier = new TamperVerifier(tamperPath.str());
    if (tamperVerifier->isBlocked()) {
        logger->writeLineData((char*) "Equipamento bloqueado");
    } else {
        logger->writeLineData((char*) "Equipamento liberado");
    }

    //Inicializando sensores
    logger->writeLineData((char*) "Inicializando sensores");

    gettimeofday(&lastWarningBatterySensor, NULL); //último aviso bateria
    gettimeofday(&lastWarningFewPaperSensor, NULL); //último aviso pouco papel
    gettimeofday(&lastWarningNoPaper, NULL); //último aviso sem papel
    gettimeofday(&lastWarningPrinterError, NULL); //último aviso impressora
    //inicializando timeouts de sensores
    lastWarningBatterySensor.tv_sec -= 55;
    lastWarningFewPaperSensor.tv_sec -= 55;
    lastWarningNoPaper.tv_sec -= 55;
    lastWarningPrinterError.tv_sec -= 55;

    sensorBattery = new BatterySensor(iGpioFd);
    sensorPaper = new PaperSensor(iGpioFd);
    sensorTamper = new TamperSensor(iGpioFd);

    sensorBattery->setSensorEventHandler(this, Prisma::batteryEventWrapper);
    sensorPaper->setSensorEventHandler(this, Prisma::paperEventWrapper);
    sensorTamper->setSensorEventHandler(this, Prisma::tamperEventWrapper);

    sensorBattery->startThd();
    sensorPaper->startThd();
    sensorTamper->startThd();


    logger->writeLineData((char*) "Inicializando controle de leds");

    //Inicializando leds
    leds = new Leds(iGpioFd);
    leds->setLed(Leds::LT_NONE);

    logger->writeLineData((char*) "Inicializando sistema de áudio");

    //Inicializando áudio
    wave = Wave::getInstance();
    wave->init(DEF_AUDIO_DEVICE);
    //configurando volume do áudio
    wave->setVolume(configuration->getVolume() * 10);
    //playAudio(AUDIO_INITIALIZE);

    logger->writeLineData((char*) "Inicializando entrada de dados");

    //Inicializando teclado matricial
    keyboard = new GPIOKeyboard(iGpioFd);

    //Inicializando leitoras de cartões
    switch (configuration->getTpCardReader()) {
        case Configuration::CRT_WIEGAND: cardReader = new Wiegand(iGpioFd);
            break;
        case Configuration::CRT_ABATRACKII: cardReader = new Abatrack(iGpioFd);
            break;
        case Configuration::CRT_NONE: cardReader = new Abatrack(iGpioFd);
            break;
            //case Configuration::CRT_BARCODE: cardReader = new Barcode(iGpioFd);
        default: cardReader = new Barcode(iGpioFd);
            break;
    }

    //Inicializando biometria
    //TODO alterar Dsp para /dev/ttyS0 para a versão final
    logger->writeLineData((char*) "Inicializando biometria");
    biometric = Dsp::getInstance((char*) DEF_DSP_DEV);
    if (configuration->getTpBiometric() != Configuration::BT_NONE) {
        int result = biometric->init();
        if (result == OK) {
            result = this->configureDSP();
        }
        logger->writeLineData(
                (result == OK) ? (char*) "Biometria inicializada com sucesso" :
                (char*) "Falha ao inicializar biometria");
        if (configuration->getAutoOn()) {
            unsigned char tmp;
            biometric->freeScan(true, &tmp);
            logger->writeLineData(
                    (tmp == DSP_SUCESS) ? (char*) "Auto on inicializado" :
                    (char*) "Falha ao inicializar Auto on");
        }
        biometric->setDspEventHandler(this, &Prisma::biometricReadedEventWrapper);
    }

    logger->writeLineData((char*) "Inicializando módulo telemática");
    telematica = new Telematica();
    stringstream telematicaPath;
    telematicaPath << DIR_HOME << DIR_PRISMA << DIR_DOCS << FILE_TELEMATICA;
    if (access(telematicaPath.str().c_str(), F_OK) == OK) {
        if (telematica->init(telematicaPath.str()) == OK) {
            logger->writeLineData((char*) "Sucesso para inicializar módulo telemática");
        } else {
            logger->writeLineData((char*) "Falha para inicializar módulo telemática");
        }
    } else {
        logger->writeLineData((char*) "Não há arquivo telemática");
    }

    logger->writeLineData((char*) "Inicializando impressora");

    //Inicializando impressora
    printer = new Printer();
    if (printer->init((char*) DEF_PRINTER_DEV) == OK) {
        logger->writeLineData((char*) "Impressora inicializada com sucesso");
        printer->setEventHandler(this, &Prisma::printerEventWrapper);

        paperStatus = PRINTER_FLAG_PAPER_OK;
        printerError = PRINTER_FLAG_PAPER_OK;

        //TODO - Descomentar na versão final
        //printer->print((char*) MSG_RECEIPT_HEADER, Printer::FM_PRINTER,
        //        Printer::CUT_NONE);
    } else {
        logger->writeLineData((char*) "Falha ao inicializar impressora");
        //TODO mensagem no display e bloqueio do equipamento
    }


    logger->writeLineData((char*) "Inicializando caches e controle de threads");

    //Inicializando buffers de entrada
    cacheKeyboard = new Cache();
    cacheCardReader = new Cache();
    cacheBiometry = new Cache();


    logger->writeLineData((char*) "Inicializando threads de leitura de dados");

    //Inicializando threads de leitura de dados
    keyboard->setPressedButtonEventHandler(this, &Prisma::keyPressedEventWrapper);
    keyboard->setReleasedButtonEventHandler(this, &Prisma::keyReleasedEventWrapper);
    keyboard->startThd();

    cardReader->setCardReadEventHandler(this, &Prisma::cardReadedEventWrapper);
    if (configuration->getTpCardReader() != Configuration::CRT_NONE) {
        cardReader->startThd();
    }

    logger->writeLineData((char*) "Criando menus");
    menuMain = MenuMain::getInstance(cacheKeyboard, display, db);

    logger->writeLineData((char*) "Inicializando threads auxiliares");


    logger->writeLineData((char*) "Criando thread de verificação cache de "
            "teclado");
    //Criando thread de verificação cache de teclado
    keyboardCacheMonitor = new Threader(10);
    keyboardCacheMonitor->setEventHandler(this, NULL,
            &Prisma::verifyKeyboardCacheWrapper);
    keyboardCacheMonitor->startThread();

    logger->writeLineData((char*) "Criando thread de verificação de cache de "
            "cartões");
    //Criando thread de verificação de cache de cartões
    cardCacheMonitor = new Threader(10);
    cardCacheMonitor->setEventHandler(this, NULL,
            &Prisma::verifyCardCacheWrapper);
    cardCacheMonitor->startThread();

    inputInfoMonitor = new Threader(500);
    inputInfoMonitor->setEventHandler(this, NULL,
            &Prisma::verifyInfoMonitorWrapper);

    tamperMonitor = new Threader(100);
    tamperMonitor->setEventHandler(this, NULL, &Prisma::verifyTamperWrapper);

    //TODO adicionar database monitor no setalertlevel
    databaseMonitor = new Threader(500);
    databaseMonitor->setEventHandler(this, NULL,
            &Prisma::verifyDataBaseModificationsWrapper);
    databaseMonitor->startThread();


    logger->writeLineData((char*) "Inicializando gerenciador do gerador de AFD");
    //Inicializando gerenciador do gerador de AFD
    afdManager = NULL;

    printf("Criando dir manager\n");
    dirManager = new DirManager(DIR_AFD, 100);
    dirManager->setDirMonitorEventHandler(this, &Prisma::dirManagerEventWrapper);
    dirManager->umontDir(DIR_AFD);
    dirManager->eraseDir(DIR_AFD);
    if (dirManager->monitor() == OK) {
        logger->writeLineData((char*) "Gerenciador de diretórios inicializado "
                "com sucesso");
    } else {
        logger->writeLineData((char*) "Falha ao inicializar gerenciador de "
                "diretórios");
        //TODO mensagem no display e bloqueio do equipamento pois não poderá
        //gerar AFD
    }

    printf("Criando dir docs\n");
    //aproveitando instância do dirManager para criar diretórios necessários
    stringstream dirDocs;
    dirDocs << DIR_HOME << DIR_PRISMA << DIR_DOCS;
    printf("verificando acesso\n");
    if (access(dirDocs.str().c_str(), F_OK) != OK) {
        printf("criando diretório\n");
        dirManager->createDir(dirDocs.str());
    }
    printf("Criando dir logs\n");
    stringstream dirLogs;
    dirLogs << DIR_HOME << DIR_PRISMA << DIR_LOGS;
    if (access(dirLogs.str().c_str(), F_OK) != OK) {
        dirManager->createDir(dirLogs.str());
    }

    sleep(1);

    printf("Verificando se está bloqueado\n");
    if (tamperVerifier->isBlocked()) {
        printf("alert level\n");
        setAlertLevel(LVL_TAMPER, ON);
        tamperMonitor->startThread();
    }

    //Inicializando menu principal
    logger->writeLineData((char*) "Inicializando menu principal");
    menuMain = MenuMain::getInstance(cacheKeyboard, display, db);
    menuMain->executeMenu();

    return OK;
}

int Prisma::terminate() {
    try {
        logger->writeLineData((char*) "Finalizando Sistema Prisma");

        //Finalizando componentes de hardware

        //Finalizando threads de controle
        logger->writeLineData((char*) "Finalizando threads de controle");

        keyboardCacheMonitor->terminate();
        cardCacheMonitor->terminate();
        inputInfoMonitor->terminate();


        //Finalizando menu principal
        logger->writeLineData((char*) "Finalizando menu principal");

        menuMain->terminate();
        delete(menuMain);


        //Finalizando threads de leitura de dados
        logger->writeLineData((char*) "Finalizando threads de leitura de "
                "dados");

        printf("finalizando thread leitura\n");

        keyboard->terminate();
        keyboard->setPressedButtonEventHandler(this, NULL);
        keyboard->setReleasedButtonEventHandler(this, NULL);
        delete(keyboard);

        printf("finalizando thread card reader\n");

        cardReader->terminate();
        cardReader->setCardReadEventHandler(this, NULL);
        delete(cardReader);

        printf("finalizando thread caches\n");

        /*
                logger->writeLineData((char*) "Finalizando caches");

                //FIXME Provável erro aqui
                cacheKeyboard->dumpCache();
                cacheCardReader->dumpCache();
                delete(cacheKeyboard);
                delete(cacheCardReader);
         */

        logger->writeLineData((char*) "Finalizando sensores");


        printf("finalizando rtc\n");
        rtc->setChangedDateTimeEventHandler(this, NULL);
        rtc->terminate();
        delete(rtc);

        printf("finalizando sensores\n");

        sensorBattery->setSensorEventHandler(this, NULL);
        sensorBattery->terminate();
        delete(sensorBattery);
        sensorPaper->setSensorEventHandler(this, NULL);
        sensorPaper->terminate();
        delete(sensorPaper);
        sensorTamper->setSensorEventHandler(this, NULL);
        sensorTamper->terminate();
        delete(sensorTamper);

        // Finalizando display
        //printando nome e versão do fw
        logger->writeLineData((char*) "Finalizando display");


#ifdef PRISMA_DISPLAY_128X64
        //((InterfaceDisplay128x64*) display)->
        display = new InterfaceDisplay128x64(iGpioFd);
#else
        ((InterfaceDisplay16x2*) display)->~InterfaceDisplay16x2();
#endif

        logger->terminate();
        delete(logger);

    } catch (...) {

    }
    return 0;
}
